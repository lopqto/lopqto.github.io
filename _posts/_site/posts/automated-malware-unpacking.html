<p>Probably most of the malwares out there use some sort of packer to evade detection and classification or to make the post-analysis more difficult. So in this blog post, I will talk about one of the most-used packing techniques and how to SOMETHING_ELSE that with the power of binary emulation. Also, I’ll drop a PoC of the new project that I’m working on.</p>

<h3 id="background">Background</h3>
<p>For packers that encrypt or compress a payload, a stub (a piece of code that contains the decompression or decryption routine) acts as a loader, which executes before the malware. So, we have a loader that decrypts or decompress the real malware to execute it. Stub can use so many techniques to achieve its goal.</p>

<p>There is a technique called self-modifying. In this technique, stub tries to acquire a block of writeable, executable memory, unpack (decrypt/decompress and write) code to the newly allocated memory and finally, transfer execution to the unpacked code in the newly allocated memory.
So, if we manage to somehow read that allocated memory and dump the executable payload, right before the execution, we probably unpacked the real malware.</p>

<h3 id="digging-down">Digging down</h3>
<p>Let’s dig down more and talk about some Windows APIs. To acquire a new block of memory, malwares will try to use <code class="highlighter-rouge">VirtualAlloc()</code>. <code class="highlighter-rouge">VirtualAlloc()</code> is a Windows API inside <code class="highlighter-rouge">kernel32.dll</code>. According to Microsoft docs, <code class="highlighter-rouge">VirtualAlloc()</code>:</p>
<blockquote>
  <p>Reserves, commits, or changes the state of a region of pages in the virtual address space of the calling process. Memory allocated by this function is automatically initialized to zero.</p>
</blockquote>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">LPVOID</span> <span class="nf">VirtualAlloc</span><span class="p">(</span>
  <span class="n">LPVOID</span> <span class="n">lpAddress</span><span class="p">,</span>
  <span class="n">SIZE_T</span> <span class="n">dwSize</span><span class="p">,</span>
  <span class="n">DWORD</span>  <span class="n">flAllocationType</span><span class="p">,</span>
  <span class="n">DWORD</span>  <span class="n">flProtect</span>
<span class="p">);</span>
</code></pre></div></div>

<p>Important variables here are <code class="highlighter-rouge">dwSize</code>, <code class="highlighter-rouge">flProtect</code>, and the return value. <code class="highlighter-rouge">dwSize</code> will define allocated memory block’s size, <code class="highlighter-rouge">flProtect</code> will define the memory protection and the return value will be the address of the newly allocated memory.</p>

<p>First of all, we need to catch <code class="highlighter-rouge">flProtect</code>, since in order to execute code inside a memory region, protection value must be one of the following values:</p>
<ul>
  <li>PAGE_EXECUTE (0x10)</li>
  <li>PAGE_EXECUTE_READ (0x20)</li>
  <li>PAGE_EXECUTE_READWRITE (0x40)</li>
  <li>PAGE_EXECUTE_WRITECOPY (0x80)</li>
</ul>

<p>So, we need to monitor dynamically allocated memories with executing protection cause they suggest that malware is about to unpack (or otherwise obtain) code to store there.</p>

<p>There is another interesting API called <code class="highlighter-rouge">VirtualProtect()</code>. <code class="highlighter-rouge">VirtualProtect()</code> changes the protection of a memory region. Malware can use this API call to change the protection of the allocated memory region if it is not already executable.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BOOL</span> <span class="nf">VirtualProtect</span><span class="p">(</span>
  <span class="n">LPVOID</span> <span class="n">lpAddress</span><span class="p">,</span>
  <span class="n">SIZE_T</span> <span class="n">dwSize</span><span class="p">,</span>
  <span class="n">DWORD</span>  <span class="n">flNewProtect</span><span class="p">,</span>
  <span class="n">PDWORD</span> <span class="n">lpflOldProtect</span>
<span class="p">);</span>
</code></pre></div></div>

<p>Important variable is <code class="highlighter-rouge">flNewProtect</code>. like <code class="highlighter-rouge">VirtualAlloc()</code> if <code class="highlighter-rouge">flNewPortect</code> contains one of the excution values (0x10, 0x20, 0x40 or 0x80) we need to monitor that specific region for unpacked code.</p>

<p>After we managed to list memory regions with execute protection, we need to set a memory execution breakpoint at those locations. So, if any code executes inside that region (probably unpacked code), we can catch and dump it.</p>

<h3 id="choosing-tools-and-solutions">Choosing tools and solutions</h3>
<p>I needed a solution to write a cross-platform tool for automatically unpacking malwares with minimal requirements. as a python developer, I prefer a framework written in python or with a python binding. So I chose a binary emulator <a href="https://www.qiling.io/">qiling!</a>.</p>

<blockquote>
  <p>Qiling Framework is aimed to change IoT security research, malware analysis and reverse engineering landscape. The main objective is to build a cross-platform and multi-architecture framework and not just another reverse engineering tool.
Qiling Framework is designed as a binary instrumentation and binary emulation framework that supports cross-platform and multi-architecture. It is packed with powerful features such as code interception and arbitrary code injection before or during a binary execution. It is also able to patch a packed binary during execution.
Qiling Framework is open source and it is written in Python, a simple and commonly used programming language. This will encourage continuous contributions from the security and open-source community making it a sustainable project.</p>
</blockquote>

<p>Also, there is a comparison between qiling with other tools. take a look at <a href="https://www.qiling.io/comparison/">this!</a>.</p>

<h3 id="writing-a-poc">Writing a PoC</h3>

<p>First of all, we need to re-implement <code class="highlighter-rouge">VirtualAlloc()</code> and <code class="highlighter-rouge">VirtualProtect()</code> APIs in a format that qiling recognizes. To make this happen, we need to write something like this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">winapi</span><span class="p">(</span><span class="n">cc</span><span class="o">=</span><span class="n">STDCALL</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">{</span>
    <span class="s">"lpAddress"</span><span class="p">:</span> <span class="n">POINTER</span><span class="p">,</span>
    <span class="s">"dwSize"</span><span class="p">:</span> <span class="n">SIZE_T</span><span class="p">,</span>
    <span class="s">"flAllocationType"</span><span class="p">:</span> <span class="n">DWORD</span><span class="p">,</span>
    <span class="s">"flProtect"</span><span class="p">:</span> <span class="n">DWORD</span>
<span class="p">})</span>
<span class="k">def</span> <span class="nf">hook_VirtualAlloc</span><span class="p">(</span><span class="n">ql</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="n">dwSize</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s">"dwSize"</span><span class="p">]</span>
    <span class="n">addr</span> <span class="o">=</span> <span class="n">ql</span><span class="o">.</span><span class="n">os</span><span class="o">.</span><span class="n">heap</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">dwSize</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">addr</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">winapi</code> is a decorator that helps to define the structure of the API call. Here we have an API with calling convention of <code class="highlighter-rouge">STDCALL</code> and 4 inputs with the type of <code class="highlighter-rouge">POINTER</code>, <code class="highlighter-rouge">SIZE_T</code>, <code class="highlighter-rouge">DWORD</code>, and yet another <code class="highlighter-rouge">DWORD</code>.</p>

<p>qiling will pass <code class="highlighter-rouge">ql</code> (sandbox) object as a parameter and <code class="highlighter-rouge">address</code> of the location that called the API. <code class="highlighter-rouge">params</code> will be a dictionary that contains all passed parameters to that API call.</p>

<p>For <code class="highlighter-rouge">VirtualProtect()</code> we can write something like this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">winapi</span><span class="p">(</span><span class="n">cc</span><span class="o">=</span><span class="n">STDCALL</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">{</span>
    <span class="s">"lpAddress"</span><span class="p">:</span> <span class="n">POINTER</span><span class="p">,</span>
    <span class="s">"dwSize"</span><span class="p">:</span> <span class="n">UINT</span><span class="p">,</span>
    <span class="s">"flNewProtect"</span><span class="p">:</span> <span class="n">UINT</span><span class="p">,</span>
    <span class="s">"lpflOldProtect"</span><span class="p">:</span> <span class="n">POINTER</span>
<span class="p">})</span>
<span class="k">def</span> <span class="nf">hook_VirtualProtect</span><span class="p">(</span><span class="n">ql</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">1</span>
</code></pre></div></div>

<p>To hook re-implemented APIs, qiling offers <code class="highlighter-rouge">set_api</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ql</span><span class="o">.</span><span class="n">set_api</span><span class="p">(</span><span class="s">"VirtualAlloc"</span><span class="p">,</span> <span class="n">hook_VirtualAlloc</span><span class="p">)</span>
<span class="n">ql</span><span class="o">.</span><span class="n">set_api</span><span class="p">(</span><span class="s">"VirtualProtect"</span><span class="p">,</span> <span class="n">hook_VirtualProtect</span><span class="p">)</span>
</code></pre></div></div>
<p>Inside hooked APIs we need to catch allocated memory regions with executable protection:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">addr</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s">"lpAddress"</span><span class="p">]</span>
<span class="n">dw_size</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s">"dwSize"</span><span class="p">]</span>
<span class="n">fl_new_protect</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s">"flNewProtect"</span><span class="p">]</span>

<span class="c1"># PAGE_EXECUTE (0x10), 
# PAGE_EXECUTE_READ (0x20), 
# PAGE_EXECUTE_READWRITE (0x40), 
# PAGE_EXECUTE_WRITECOPY (0x80),
</span><span class="k">if</span> <span class="n">fl_new_protect</span> <span class="ow">in</span> <span class="p">[</span><span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">]:</span>
    <span class="c1"># add newly allocated memory to list of memory regions
</span>    <span class="n">mem_regions</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s">"start"</span><span class="p">:</span> <span class="n">addr</span><span class="p">,</span> <span class="s">"size"</span><span class="p">:</span> <span class="n">dw_size</span><span class="p">})</span>
</code></pre></div></div>
<p>The next step will set up a memory execution breakpoint. qiling offers a function called <code class="highlighter-rouge">hook_code()</code>. <code class="highlighter-rouge">hook_code()</code> takes 3 parameters. a callback function, beginning, and end of the memory region.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ql</span><span class="o">.</span><span class="n">hook_code</span><span class="p">(</span><span class="n">dump_memory_region</span><span class="p">,</span> <span class="n">begin</span><span class="o">=</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">addr</span> <span class="o">+</span> <span class="n">dw_size</span><span class="p">)</span>
</code></pre></div></div>

<p>If any code get excuted inside that memory region, qiling will call <code class="highlighter-rouge">dump_memory_region()</code>. To dump that region, qiling offers <code class="highlighter-rouge">ql.mem.read()</code>. <code class="highlighter-rouge">read()</code> takes 2 parameters, start location and size.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">excuted_mem</span> <span class="o">=</span> <span class="n">ql</span><span class="o">.</span><span class="n">mem</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
</code></pre></div></div>
<p>Full code for PoC will be:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">from</span> <span class="nn">qiling</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">qiling.os.windows.const</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">qiling.os.const</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">qiling.os.windows.fncc</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">qiling.os.windows.utils</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">qiling.os.windows.thread</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">qiling.os.windows.handle</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">qiling.exception</span> <span class="kn">import</span> <span class="o">*</span>


<span class="n">mem_regions</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">def</span> <span class="nf">get_mem</span><span class="p">(</span><span class="n">addr</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">mem_region</span> <span class="ow">in</span> <span class="n">mem_regions</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">mem_region</span><span class="p">[</span><span class="s">'start'</span><span class="p">]</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">mem_region</span><span class="p">[</span><span class="s">'start'</span><span class="p">]</span> <span class="o">+</span> <span class="n">mem_region</span><span class="p">[</span><span class="s">'size'</span><span class="p">]</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">mem_region</span><span class="p">[</span><span class="s">'size'</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">addr</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="bp">None</span>
            

<span class="k">def</span> <span class="nf">dump_memory_region</span><span class="p">(</span><span class="n">ql</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
    <span class="n">mem_region</span> <span class="o">=</span> <span class="n">get_mem</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
    <span class="c1"># check if that memory region got removed before (duplication)
</span>    <span class="k">if</span> <span class="n">mem_region</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c1"># read memory, start =  first excuted address ; end = end of the region
</span>        <span class="n">excuted_mem</span> <span class="o">=</span> <span class="n">ql</span><span class="o">.</span><span class="n">mem</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">mem_region</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">f</span><span class="s">"{hex(address)}.bin"</span><span class="p">,</span> <span class="s">"wb"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">excuted_mem</span><span class="p">)</span>
        
        <span class="c1"># delete that region to overcome duplication
</span>        <span class="n">mem_regions</span><span class="o">.</span><span class="n">remove</span><span class="p">({</span><span class="s">"start"</span><span class="p">:</span> <span class="n">mem_region</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">"size"</span><span class="p">:</span><span class="n">mem_region</span><span class="p">[</span><span class="mi">1</span><span class="p">]})</span>

<span class="o">@</span><span class="n">winapi</span><span class="p">(</span><span class="n">cc</span><span class="o">=</span><span class="n">STDCALL</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">{</span>
    <span class="s">"lpAddress"</span><span class="p">:</span> <span class="n">POINTER</span><span class="p">,</span>
    <span class="s">"dwSize"</span><span class="p">:</span> <span class="n">UINT</span><span class="p">,</span>
    <span class="s">"flNewProtect"</span><span class="p">:</span> <span class="n">UINT</span><span class="p">,</span>
    <span class="s">"lpflOldProtect"</span><span class="p">:</span> <span class="n">POINTER</span>
<span class="p">})</span>

<span class="k">def</span> <span class="nf">hook_VirtualProtect</span><span class="p">(</span><span class="n">ql</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>

    <span class="n">addr</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s">"lpAddress"</span><span class="p">]</span>
    <span class="n">dw_size</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s">"dwSize"</span><span class="p">]</span>
    <span class="n">fl_new_protect</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s">"flNewProtect"</span><span class="p">]</span>

    <span class="c1"># PAGE_EXECUTE (0x10), 
</span>    <span class="c1"># PAGE_EXECUTE_READ (0x20), 
</span>    <span class="c1"># PAGE_EXECUTE_READWRITE (0x40), 
</span>    <span class="c1"># PAGE_EXECUTE_WRITECOPY (0x80),
</span>    <span class="k">if</span> <span class="n">fl_new_protect</span> <span class="ow">in</span> <span class="p">[</span><span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">]:</span>
        <span class="c1"># add newly allocated memory to list of memory regions
</span>        <span class="n">mem_regions</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s">"start"</span><span class="p">:</span> <span class="n">addr</span><span class="p">,</span> <span class="s">"size"</span><span class="p">:</span> <span class="n">dw_size</span><span class="p">})</span>
        <span class="c1"># add memory on excute breakpoint to newly allocated memory
</span>        <span class="n">ql</span><span class="o">.</span><span class="n">hook_code</span><span class="p">(</span><span class="n">dump_memory_region</span><span class="p">,</span> <span class="n">begin</span><span class="o">=</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">addr</span> <span class="o">+</span> <span class="n">dw_size</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">1</span>



<span class="o">@</span><span class="n">winapi</span><span class="p">(</span><span class="n">cc</span><span class="o">=</span><span class="n">STDCALL</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">{</span>
    <span class="s">"lpAddress"</span><span class="p">:</span> <span class="n">POINTER</span><span class="p">,</span>
    <span class="s">"dwSize"</span><span class="p">:</span> <span class="n">SIZE_T</span><span class="p">,</span>
    <span class="s">"flAllocationType"</span><span class="p">:</span> <span class="n">DWORD</span><span class="p">,</span>
    <span class="s">"flProtect"</span><span class="p">:</span> <span class="n">DWORD</span>
<span class="p">})</span>

<span class="k">def</span> <span class="nf">hook_VirtualAlloc</span><span class="p">(</span><span class="n">ql</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="n">dw_size</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s">"dwSize"</span><span class="p">]</span>
    <span class="n">addr</span> <span class="o">=</span> <span class="n">ql</span><span class="o">.</span><span class="n">os</span><span class="o">.</span><span class="n">heap</span><span class="o">.</span><span class="n">mem_alloc</span><span class="p">(</span><span class="n">dw_size</span><span class="p">)</span>

    <span class="c1"># PAGE_EXECUTE (0x10), 
</span>    <span class="c1"># PAGE_EXECUTE_READ (0x20), 
</span>    <span class="c1"># PAGE_EXECUTE_READWRITE (0x40), 
</span>    <span class="c1"># PAGE_EXECUTE_WRITECOPY (0x80),
</span>    <span class="n">fl_protect</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s">"flProtect"</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">fl_protect</span> <span class="ow">in</span> <span class="p">[</span><span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">]</span> <span class="p">:</span>

        <span class="c1"># add newly allocated memory to list of memory regions
</span>        <span class="n">mem_regions</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s">"start"</span><span class="p">:</span> <span class="n">addr</span><span class="p">,</span> <span class="s">"size"</span><span class="p">:</span> <span class="n">dw_size</span><span class="p">})</span>
        <span class="c1"># add memory on excute breakpoint to newly allocated memory
</span>        <span class="n">ql</span><span class="o">.</span><span class="n">hook_code</span><span class="p">(</span><span class="n">dump_memory_region</span><span class="p">,</span> <span class="n">begin</span><span class="o">=</span><span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">addr</span> <span class="o">+</span> <span class="n">dw_size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">addr</span>


<span class="k">def</span> <span class="nf">sandbox</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">rootfs</span><span class="p">):</span>
    <span class="n">ql</span> <span class="o">=</span> <span class="n">Qiling</span><span class="p">([</span><span class="n">path</span><span class="p">],</span> <span class="s">"rootfs/x86_windows"</span><span class="p">,</span> <span class="n">output</span> <span class="o">=</span> <span class="s">"debug"</span><span class="p">)</span>

    <span class="c1"># set API breakpoints
</span>    <span class="n">ql</span><span class="o">.</span><span class="n">set_api</span><span class="p">(</span><span class="s">"VirtualAlloc"</span><span class="p">,</span> <span class="n">hook_VirtualAlloc</span><span class="p">)</span>
    <span class="n">ql</span><span class="o">.</span><span class="n">set_api</span><span class="p">(</span><span class="s">"VirtualProtect"</span><span class="p">,</span> <span class="n">hook_VirtualProtect</span><span class="p">)</span>

    <span class="n">ql</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="nb">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">path</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">sandbox</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">"rootfs/x86_windows"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="demonstration">Demonstration</h3>
<p>For demonstration, i wrote a small program that runs a shellcode.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;windows.h&gt;
#include &lt;iostream&gt;
</span>
<span class="kt">char</span> <span class="n">shellcode</span><span class="p">[</span><span class="mi">113</span><span class="p">]</span> <span class="o">=</span>   <span class="s">"</span><span class="se">\x31\xdb\x64\x8b\x7b\x30\x8b\x7f</span><span class="s">"</span>
                        <span class="s">"</span><span class="se">\x0c\x8b\x7f\x1c\x8b\x47\x08\x8b</span><span class="s">"</span>
                        <span class="s">"</span><span class="se">\x77\x20\x8b\x3f\x80\x7e\x0c\x33</span><span class="s">"</span>
                        <span class="s">"</span><span class="se">\x75\xf2\x89\xc7\x03\x78\x3c\x8b</span><span class="s">"</span>
                        <span class="s">"</span><span class="se">\x57\x78\x01\xc2\x8b\x7a\x20\x01</span><span class="s">"</span>
                        <span class="s">"</span><span class="se">\xc7\x89\xdd\x8b\x34\xaf\x01\xc6</span><span class="s">"</span>
                        <span class="s">"</span><span class="se">\x45\x81\x3e\x43\x72\x65\x61\x75</span><span class="s">"</span>
                        <span class="s">"</span><span class="se">\xf2\x81\x7e\x08\x6f\x63\x65\x73</span><span class="s">"</span>
                        <span class="s">"</span><span class="se">\x75\xe9\x8b\x7a\x24\x01\xc7\x66</span><span class="s">"</span>
                        <span class="s">"</span><span class="se">\x8b\x2c\x6f\x8b\x7a\x1c\x01\xc7</span><span class="s">"</span>
                        <span class="s">"</span><span class="se">\x8b\x7c\xaf\xfc\x01\xc7\x89\xd9</span><span class="s">"</span>
                        <span class="s">"</span><span class="se">\xb1\xff\x53\xe2\xfd\x68\x63\x61</span><span class="s">"</span>
                        <span class="s">"</span><span class="se">\x6c\x63\x89\xe2\x52\x52\x53\x53</span><span class="s">"</span>
                        <span class="s">"</span><span class="se">\x53\x53\x53\x53\x52\x53\xff\xd7</span><span class="s">"</span><span class="p">;</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">old_protect</span><span class="p">;</span>
    <span class="n">LPVOID</span> <span class="n">executable_area</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">113</span><span class="p">,</span> <span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_READWRITE</span><span class="p">);</span>
    <span class="n">executable_area</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">(</span><span class="n">executable_area</span><span class="p">,</span> <span class="mi">113</span><span class="p">,</span> <span class="n">MEM_COMMIT</span><span class="p">,</span> <span class="n">PAGE_READWRITE</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">executable_area</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"error in allocating memory"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="n">executable_area</span><span class="p">,</span> <span class="n">shellcode</span><span class="p">,</span> <span class="mi">113</span><span class="p">);</span>
    <span class="n">VirtualProtect</span><span class="p">(</span><span class="n">executable_area</span><span class="p">,</span> <span class="mi">113</span><span class="p">,</span> <span class="n">PAGE_EXECUTE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old_protect</span><span class="p">);</span>

    <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)()</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)())</span> <span class="n">executable_area</span><span class="p">;</span>
    <span class="n">f</span><span class="p">();</span>

    <span class="n">VirtualFree</span><span class="p">(</span><span class="n">executable_area</span><span class="p">,</span> <span class="mi">113</span><span class="p">,</span> <span class="n">MEM_RELEASE</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>We can try the PoC for that program and see output:
<img src="/img/automated-malware-unpacking1.png" alt="PoC output" />
<img src="/img/automated-malware-unpacking2.png" alt="PoC output" /></p>

<p>We managed to dump the shellcode successfully. I hope this was helpful. :)</p>

<h3 id="read-more">Read more</h3>

<ul>
  <li><a href="https://qiling.io/">qiling website</a></li>
  <li><a href="https://docs.qiling.io/">qiling docs</a></li>
  <li><a href="https://www.youtube.com/watch?v=FctDptnYukQ">OALabs youtube video about automated malware unpacking</a></li>
</ul>
