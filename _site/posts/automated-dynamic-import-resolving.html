<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Automated dynamic import resolving using binary emulation « lopqto's adventures</title>
  <meta name="description" content="Analyzing malwares is often not an easy task because there are lots of tricks and techniques that malwares use to evade detection and classification or to ma...">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:wght@400;600;700&display=swap">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:wght@400;600;700&display=swap" media="print" onload="this.media='all'">
  <noscript>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:wght@400;600;700&display=swap">
  </noscript>
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://lopqto.me/posts/automated-dynamic-import-resolving">
  <link rel="shortcut icon" type="image/png" href="/favicon.png">
  <link rel="alternate" type="application/rss+xml" title="lopqto's adventures" href="https://lopqto.me/feed.xml" />
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">lopqto's adventures</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/category/">Category</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">Automated dynamic import resolving using binary emulation</h1>
    <p class="post-meta">Sep 8, 2020</p>
  </header>

  <article class="post-content">
    <p>Analyzing malwares is often not an easy task because there are lots of tricks and techniques that malwares use to evade detection and classification or to make the post-analysis more difficult. One such trick is to resolve windows API calls dynamically (called “dynamic import resolving”).</p>

<p>In this blog post, we will talk about dynamic import resolving and a pattern to detect it when reversing malwares, how to defeat this trick using binary emulation and Qiling framework (resolve API calls and extract function names), and finally we will integrate our emulation framework with Ghidra.</p>

<p>In the last section, we will talk about a solution to run Python version 3 and Qiling trough Ghidra so we can see the result of our script inside the decompiler/disassembler view. It will make post-analysis easier.</p>

<p>As a real-life example, we will analyze Netwalker which used this technique and we will discuss our idea around that sample.</p>

<h3 id="what-is-dynamic-import-resolving">What is dynamic import resolving</h3>
<p>Let’s talk about dynamic import resolving and indirect function calls. It’s a common technique that malwares use to hide their intention, make the static analysis more difficult, bypass some red flags, etc.</p>

<p>In this technique, the malware tries to create an IAT (<a href="https://en.wikipedia.org/wiki/Portable_Executable">Import Address Table</a>) during the execution so there is no sign of used API calls in the PE header.</p>

<p>This technique often shows up in a specific pattern;
At the beginning of the execution, the program will build an array of function pointers which  works like an IAT and the malware can use stored function pointers with indirect calls as shown below:</p>

<p><img src="/img/daily-binary-emulation3.png" alt="indirect calls" /></p>

<p>It’s rather difficult to determine which function would be called by these indirect function calls without actually executing the binary.</p>

<p>To dynamically make a function pointer, the two API calls <code class="language-plaintext highlighter-rouge">LoadLibraryA()</code> and <code class="language-plaintext highlighter-rouge">GetProcAddress()</code> are often used.</p>

<p>According to the Microsoft docs, <code class="language-plaintext highlighter-rouge">LoadLibraryA()</code>:</p>

<blockquote>
  <p>Loads the specified module into the address space of the calling process. The specified module may cause other modules to be loaded.</p>
</blockquote>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HMODULE</span> <span class="nf">LoadLibraryA</span><span class="p">(</span>
  <span class="n">LPCSTR</span> <span class="n">lpLibFileName</span>
<span class="p">);</span>
</code></pre></div></div>

<p>And <code class="language-plaintext highlighter-rouge">GetProcAddress()</code>:</p>

<blockquote>
  <p>Retrieves the address of an exported function or variable from the specified dynamic-link library (DLL).</p>
</blockquote>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">FARPROC</span> <span class="nf">GetProcAddress</span><span class="p">(</span>
  <span class="n">HMODULE</span> <span class="n">hModule</span><span class="p">,</span>
  <span class="n">LPCSTR</span>  <span class="n">lpProcName</span>
<span class="p">);</span>
</code></pre></div></div>

<p>Look at this pseudo-code as a demonstration:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="nf">ret_type</span> <span class="p">(</span><span class="kr">__stdcall</span> <span class="o">*</span><span class="n">f_func</span><span class="p">)(</span><span class="n">param_a</span><span class="p">,</span> <span class="n">param_b</span><span class="p">);</span>

<span class="n">HINSTANCE</span> <span class="n">hLibrary</span> <span class="o">=</span> <span class="n">LoadLibrary</span><span class="p">(</span><span class="s">"ntdll.dll"</span><span class="p">);</span>
<span class="n">f_func</span> <span class="n">LocalNtCreateFile</span> <span class="o">=</span> <span class="p">(</span><span class="n">f_func</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">hLibrary</span><span class="p">,</span> <span class="s">"NtCreateFile"</span><span class="p">);</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">LocalNtCreateFile</code> is a function pointer which points to <code class="language-plaintext highlighter-rouge">NtCreateFile</code>, which can be stored in an array a.k.a IAT.</p>

<p>To make things more spicy, sometimes malware authors also encrypt the strings passed to <code class="language-plaintext highlighter-rouge">LoadLibrary()</code> and <code class="language-plaintext highlighter-rouge">GetProcAddress()</code> like what Netwalker did. It will be near to impossible to analyze malware without solving this problem first.</p>

<h3 id="choosing-the-approach">Choosing the approach</h3>
<p>To solve these types of techniques and tricks there are a few approaches. For example, we can sometimes decrypt passed strings statically or we can develop an IDA plugin (or any disassembler and decompiler that supports plugins) but that would be a rather time-consuming task. Alternatively, we can use debuggers to execute the malware step by step, and rename variables according to dynamically resolved functions but this is a lot of repetition.</p>

<p>I chose binary emulation because it gives us the best of both worlds, We can have the power of automation <em>and</em> the ease of debugging. ‌It’s worth mentioning that emulating can be very slow at times, especially when dealing with encryption and decryption algorithms.
Personally, I think this is an acceptable trade-off.</p>

<p>For binary emulation we will use Qiling. Read my <a href="/posts/automated-malware-unpacking#choosing-tools-and-solutions">previous post</a> to see why.</p>

<h3 id="analyzing-netwalker">Analyzing Netwalker</h3>
<p>Today’s sample is NetWalker <a href="https://malpedia.caad.fkie.fraunhofer.de/details/win.mailto">link!</a> . Netwalker used dynamic import resolving technique with encrypted strings so it is a good example for us to demonstrate our idea and approach around that.</p>

<p>As discussed before, most of the time malwares will try to build an IAT at the beginning of the execution - and NetWalker does this.</p>

<p>After disassembling the malware, we can see a function call right after the <code class="language-plaintext highlighter-rouge">entry</code>.</p>

<p><img src="/img/daily-binary-emulation1.png" alt="build IAT function call" /></p>

<p>Jumping to that function, we can see the pattern mentioned above; A function is called multiple times and the return value is stored in an array.</p>

<p><img src="/img/daily-binary-emulation2.png" alt="IAT pattern" /></p>

<p>This pattern is a sign of dynamic import resolving. We can confirm our guess with a debugger like below:</p>

<p><img src="/img/daily-binary-emulation8.png" alt="debugger view of one of the function calls" /></p>

<p>Let’s jump to the code and write a script to extract these function names.</p>

<p>I’ve discussed the basics of the Qiling like <code class="language-plaintext highlighter-rouge">hook_code()</code> and <code class="language-plaintext highlighter-rouge">ql.mem.read</code> in the <a href="/posts/automated-malware-unpacking">previous post</a>.</p>

<p>In such scenarios, we don’t need to emulate the entire malware, we just need to execute the dynamic import table resolution bit. So we need to find the start and the end of that section. This is rather easy because our target is inside a function, so we only need to emulate that specific function.</p>

<p><img src="/img/daily-binary-emulation4.png" alt="start and end of the section" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ql</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">begin</span><span class="o">=</span><span class="mh">0x0040c1a0</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="mh">0x0040c1a5</span><span class="p">)</span>
</code></pre></div></div>

<p>In this process of analyzing malwares with binary emulation, you need only be creative.
For example, in this sample, there are plenty of approaches that you can use; however I chose the easiest and fastest (specifically development time, this solution performs rather badly).</p>

<p>Let’s talk about the approach. As you can see in the image below, the return value of the (probably) decrypter and resolver function is stored in the <code class="language-plaintext highlighter-rouge">eax</code> register and then moved to <code class="language-plaintext highlighter-rouge">dword ptr [ecx + int]</code>. So we just need to hook the code and extract the value of <code class="language-plaintext highlighter-rouge">eax</code> in the right location.</p>

<p><img src="/img/daily-binary-emulation5.png" alt="return value stored in to the eax" /></p>

<p>We can run the emulator and try to <code class="language-plaintext highlighter-rouge">hook_code()</code> to catch every instruction that is going to be executed.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ql</span><span class="p">.</span><span class="n">hook_code</span><span class="p">(</span><span class="n">extract_eax</span><span class="p">)</span>
</code></pre></div></div>

<p>As you may notice, <code class="language-plaintext highlighter-rouge">extract_eax()</code> is a callback function that is designed to extract the value of <code class="language-plaintext highlighter-rouge">eax</code>. Qiling will pass the <code class="language-plaintext highlighter-rouge">ql</code> (sandbox) object, the <code class="language-plaintext highlighter-rouge">address</code> and the <code class="language-plaintext highlighter-rouge">size</code> of the instruction to this callback function.</p>

<p>We can extract the instruction inside <code class="language-plaintext highlighter-rouge">extract_eax()</code> with <code class="language-plaintext highlighter-rouge">mem.read()</code> as below:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">buf</span> <span class="o">=</span> <span class="n">ql</span><span class="p">.</span><span class="n">mem</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">buf</code> is a Python <code class="language-plaintext highlighter-rouge">bytearray</code> of our instruction. The next step is detecting the right location to extract <code class="language-plaintext highlighter-rouge">eax</code>. By looking at the disassembler we can see a pattern. the first part of the opcode is similar.</p>

<p><img src="/img/daily-binary-emulation6.png" alt="opcode similarty" /></p>

<p>Next <code class="language-plaintext highlighter-rouge">if</code> will detect the right location:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="s">"8941"</span> <span class="ow">in</span> <span class="n">buf</span><span class="p">.</span><span class="nb">hex</span><span class="p">():</span>
</code></pre></div></div>

<p>to extract <code class="language-plaintext highlighter-rouge">eax</code> value we need to do this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">eax_value</span> <span class="o">=</span> <span class="n">ql</span><span class="p">.</span><span class="n">reg</span><span class="p">.</span><span class="n">eax</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">eax_value</code> is an address that points to an API call. We can search that address inside <code class="language-plaintext highlighter-rouge">import_symbols</code> to extract the API name.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">func</span> <span class="o">=</span> <span class="n">ql</span><span class="p">.</span><span class="n">loader</span><span class="p">.</span><span class="n">import_symbols</span><span class="p">[</span><span class="n">eax_value</span><span class="p">]</span>
<span class="n">func_dll</span> <span class="o">=</span> <span class="n">func</span><span class="p">[</span><span class="s">"dll"</span><span class="p">]</span>
<span class="n">func_name</span> <span class="o">=</span> <span class="n">func</span><span class="p">[</span><span class="s">"name"</span><span class="p">].</span><span class="n">decode</span><span class="p">(</span><span class="s">"ascii"</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"found </span><span class="si">{</span><span class="n">func_dll</span><span class="si">}</span><span class="s">.</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s"> at </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">address</span><span class="p">)</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<p>Fulll code will be:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">extract_eax</span><span class="p">(</span><span class="n">ql</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
    <span class="n">buf</span> <span class="o">=</span> <span class="n">ql</span><span class="p">.</span><span class="n">mem</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="k">if</span> <span class="s">"8941"</span> <span class="ow">in</span> <span class="n">buf</span><span class="p">.</span><span class="nb">hex</span><span class="p">():</span> <span class="c1"># dword ptr [ECX + hex],EAX
</span>        <span class="n">eax_value</span> <span class="o">=</span> <span class="n">ql</span><span class="p">.</span><span class="n">reg</span><span class="p">.</span><span class="n">eax</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">ql</span><span class="p">.</span><span class="n">loader</span><span class="p">.</span><span class="n">import_symbols</span><span class="p">[</span><span class="n">eax_value</span><span class="p">]</span>
        <span class="n">func_dll</span> <span class="o">=</span> <span class="n">func</span><span class="p">[</span><span class="s">"dll"</span><span class="p">]</span>
        <span class="n">func_name</span> <span class="o">=</span> <span class="n">func</span><span class="p">[</span><span class="s">"name"</span><span class="p">].</span><span class="n">decode</span><span class="p">(</span><span class="s">"ascii"</span><span class="p">)</span>
        
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"found </span><span class="si">{</span><span class="n">func_dll</span><span class="si">}</span><span class="s">.</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s"> at </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">address</span><span class="p">)</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<p>This was easy! right? Next, we need to integrate our scipt with Ghidra to actually use the information we got here. This will help us to see extracted API names inside Ghidra.</p>

<h3 id="integrating-qiling-with-ghidra">Integrating Qiling with Ghidra</h3>
<p>As you probably know Ghidra uses Jython and Jython only supports Python version 2 but Qiling is based on Python version 3. I found an interesting project called <code class="language-plaintext highlighter-rouge">ghidra_bridge</code> <a href="https://github.com/justfoxing/ghidra_bridge">link!</a> that helps us solve this problem.</p>

<blockquote>
  <p>So Ghidra Bridge is an effort to sidestep that problem - instead of being stuck in Jython, set up an RPC proxy for Python objects, so we can call into Ghidra/Jython-land to get the data we need, then bring it back to a more up-to-date Python with all the packages you need to do your work.</p>
</blockquote>

<p>After installing <code class="language-plaintext highlighter-rouge">ghidra_bridge</code> you can find an example inside the installation directory called <code class="language-plaintext highlighter-rouge">example_py3_from_ghidra_bridge.py</code>. By opening this file we will have an idea about how to write scripts based on <code class="language-plaintext highlighter-rouge">ghidra_bridge</code>. Let’s dissect it.</p>

<p>Most scripts should use this minimal template:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">run_script</span><span class="p">(</span><span class="n">server_host</span><span class="p">,</span> <span class="n">server_port</span><span class="p">):</span>

    <span class="kn">import</span> <span class="nn">ghidra_bridge</span> 
    <span class="k">with</span> <span class="n">ghidra_bridge</span><span class="p">.</span><span class="n">GhidraBridge</span><span class="p">(</span><span class="n">namespace</span><span class="o">=</span><span class="nb">globals</span><span class="p">(),</span> <span class="n">response_timeout</span><span class="o">=</span><span class="mi">500</span><span class="p">):</span>
        <span class="k">pass</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>

    <span class="n">in_ghidra</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">ghidra</span>
        <span class="c1"># we're in ghidra!
</span>        <span class="n">in_ghidra</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">except</span> <span class="nb">ModuleNotFoundError</span><span class="p">:</span>
        <span class="c1"># not ghidra
</span>        <span class="k">pass</span>

    <span class="k">if</span> <span class="n">in_ghidra</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">ghidra_bridge_server</span>
        <span class="n">script_file</span> <span class="o">=</span> <span class="n">getSourceFile</span><span class="p">().</span><span class="n">getAbsolutePath</span><span class="p">()</span>
        <span class="c1"># spin up a ghidra_bridge_server and spawn the script in external python to connect back to it
</span>        <span class="n">ghidra_bridge_server</span><span class="p">.</span><span class="n">GhidraBridgeServer</span><span class="p">.</span><span class="n">run_script_across_ghidra_bridge</span><span class="p">(</span><span class="n">script_file</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># we're being run outside ghidra! (almost certainly from spawned by run_script_across_ghidra_bridge())
</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="p">.</span><span class="n">ArgumentParser</span><span class="p">(</span>
            <span class="n">description</span><span class="o">=</span><span class="s">"py3 script that's expected to be called from ghidra with a bridge"</span><span class="p">)</span>
        <span class="c1"># the script needs to handle these command-line arguments and use them to connect back to the ghidra server that spawned it
</span>        <span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">"--connect_to_host"</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                            <span class="n">default</span><span class="o">=</span><span class="s">"127.0.0.1"</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">"IP to connect to the ghidra_bridge server"</span><span class="p">)</span>
        <span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">"--connect_to_port"</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                            <span class="n">help</span><span class="o">=</span><span class="s">"Port to connect to the ghidra_bridge server"</span><span class="p">)</span>

        <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="p">.</span><span class="n">parse_args</span><span class="p">()</span>

        <span class="n">run_script</span><span class="p">(</span><span class="n">server_host</span><span class="o">=</span><span class="n">args</span><span class="p">.</span><span class="n">connect_to_host</span><span class="p">,</span>
                   <span class="n">server_port</span><span class="o">=</span><span class="n">args</span><span class="p">.</span><span class="n">connect_to_port</span><span class="p">)</span>
</code></pre></div></div>

<p>We only need to focus on <code class="language-plaintext highlighter-rouge">run_script()</code> function. The other part is static and probably there is no need to change. Only inside <code class="language-plaintext highlighter-rouge">run_script()</code> you are allowed to use Python 3 syntax and only here you are allowed to load Python 3 libraries (like Qiling). As you may notice I added  <code class="language-plaintext highlighter-rouge">response_timeout</code> to the <code class="language-plaintext highlighter-rouge">GhidraBridge</code> object and sets it’s value to 500 seconds. Why? because as we discussed earlier emulating is a time-consuming task and emulating decryptor functions is likely more time-consuming because there is so much instruction code that needs to be emulated. So we need to set <code class="language-plaintext highlighter-rouge">response_timeout</code> to prevent any timeout-related errors.</p>

<p>Leaving aside the base template, we can now write our Qiling code inside <code class="language-plaintext highlighter-rouge">run_script()</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">run_script</span><span class="p">(</span><span class="n">server_host</span><span class="p">,</span> <span class="n">server_port</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">qiling</span> <span class="kn">import</span> <span class="n">Qiling</span>

    <span class="kn">import</span> <span class="nn">ghidra_bridge</span> 
    <span class="k">with</span> <span class="n">ghidra_bridge</span><span class="p">.</span><span class="n">GhidraBridge</span><span class="p">(</span><span class="n">namespace</span><span class="o">=</span><span class="nb">globals</span><span class="p">(),</span> <span class="n">response_timeout</span><span class="o">=</span><span class="mi">500</span><span class="p">):</span>

        <span class="n">ql</span> <span class="o">=</span> <span class="n">Qiling</span><span class="p">([</span><span class="s">"/home/lopqto/w/automated/samples/netwalker.exe"</span><span class="p">],</span> <span class="s">"/home/lopqto/w/automated/rootfs/x86_windows"</span><span class="p">,</span> <span class="n">output</span> <span class="o">=</span> <span class="s">"debug"</span><span class="p">)</span>
        <span class="n">ql</span><span class="p">.</span><span class="n">hook_code</span><span class="p">(</span><span class="n">extract_eax</span><span class="p">)</span>
        <span class="n">ql</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">begin</span><span class="o">=</span><span class="mh">0x0040c1a0</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="mh">0x0040c1a5</span><span class="p">)</span>
</code></pre></div></div>

<p>Back to the <code class="language-plaintext highlighter-rouge">extract_eax()</code> function, we need to integrate it with Ghidra and add extracted API names as a comment into Ghidra. To add a comment from a script first of all we need an address (location). We have the <code class="language-plaintext highlighter-rouge">address</code> value from Qiling but we need to convert this value to Ghidra’s <code class="language-plaintext highlighter-rouge">Address</code> type.</p>

<p>To do this we need <code class="language-plaintext highlighter-rouge">memory.blocks</code> object from <code class="language-plaintext highlighter-rouge">currentProgram</code> API. But there is a challenge here. <code class="language-plaintext highlighter-rouge">currentProgram</code> API only is accessible inside <code class="language-plaintext highlighter-rouge">run_script()</code>. But we need this API inside <code class="language-plaintext highlighter-rouge">extract_eax()</code> callback. There is a cool trick to handle this situation. You need to pass things around with <code class="language-plaintext highlighter-rouge">ql</code> object like below:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ql</span><span class="p">.</span><span class="n">target_block</span> <span class="o">=</span> <span class="n">currentProgram</span><span class="p">.</span><span class="n">memory</span><span class="p">.</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></div>

<p>Now we can access to <code class="language-plaintext highlighter-rouge">ql.target_block</code> inside <code class="language-plaintext highlighter-rouge">extract_eax()</code>. <code class="language-plaintext highlighter-rouge">target_block</code> (<code class="language-plaintext highlighter-rouge">memory.blocks[0]</code>) points to the PE entrypoint at <code class="language-plaintext highlighter-rouge">0x00400000</code>. to convert <code class="language-plaintext highlighter-rouge">address</code> to <code class="language-plaintext highlighter-rouge">Address</code> type we need to calculate offset and do something like this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">target_address</span> <span class="o">=</span> <span class="n">ql</span><span class="p">.</span><span class="n">target_block</span><span class="p">.</span><span class="n">getStart</span><span class="p">()</span>
<span class="n">target_address</span> <span class="o">=</span> <span class="n">target_address</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">address</span> <span class="o">-</span> <span class="mh">0x00400000</span><span class="p">)</span>
</code></pre></div></div>

<p>Now we have our <code class="language-plaintext highlighter-rouge">target_address</code> so we need one more step. accessing comment API is similar to above. First we need <code class="language-plaintext highlighter-rouge">getListring()</code> object:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ql</span><span class="p">.</span><span class="n">listing</span> <span class="o">=</span> <span class="n">currentProgram</span><span class="p">.</span><span class="n">getListing</span><span class="p">()</span>
</code></pre></div></div>

<p>And to add a comment we can do:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">codeUnit</span> <span class="o">=</span> <span class="n">ql</span><span class="p">.</span><span class="n">listing</span><span class="p">.</span><span class="n">getCodeUnitAt</span><span class="p">(</span><span class="n">target_address</span><span class="p">)</span>
<span class="n">comment_message</span> <span class="o">=</span> <span class="s">"{}.{}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">func_dll</span><span class="p">,</span> <span class="n">func_name</span><span class="p">)</span>
<span class="n">codeUnit</span><span class="p">.</span><span class="n">setComment</span><span class="p">(</span><span class="n">codeUnit</span><span class="p">.</span><span class="n">PRE_COMMENT</span><span class="p">,</span> <span class="n">comment_message</span><span class="p">)</span>
</code></pre></div></div>

<p>Full source code for <code class="language-plaintext highlighter-rouge">extract_eax()</code> will be this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">extract_eax</span><span class="p">(</span><span class="n">ql</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
    <span class="n">buf</span> <span class="o">=</span> <span class="n">ql</span><span class="p">.</span><span class="n">mem</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
    <span class="k">if</span> <span class="s">"8941"</span> <span class="ow">in</span> <span class="n">buf</span><span class="p">.</span><span class="nb">hex</span><span class="p">():</span> <span class="c1"># dword ptr [ECX + hex],EAX
</span>        
        <span class="n">eax_value</span> <span class="o">=</span> <span class="n">ql</span><span class="p">.</span><span class="n">reg</span><span class="p">.</span><span class="n">eax</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">ql</span><span class="p">.</span><span class="n">loader</span><span class="p">.</span><span class="n">import_symbols</span><span class="p">[</span><span class="n">eax_value</span><span class="p">]</span>
        <span class="n">func_dll</span> <span class="o">=</span> <span class="n">func</span><span class="p">[</span><span class="s">"dll"</span><span class="p">]</span>
        <span class="n">func_name</span> <span class="o">=</span> <span class="n">func</span><span class="p">[</span><span class="s">"name"</span><span class="p">].</span><span class="n">decode</span><span class="p">(</span><span class="s">"ascii"</span><span class="p">)</span>
        <span class="n">target_address</span> <span class="o">=</span> <span class="n">ql</span><span class="p">.</span><span class="n">target_block</span><span class="p">.</span><span class="n">getStart</span><span class="p">()</span>
        <span class="n">target_address</span> <span class="o">=</span> <span class="n">target_address</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">address</span> <span class="o">-</span> <span class="mh">0x00400000</span><span class="p">)</span>
        <span class="n">codeUnit</span> <span class="o">=</span> <span class="n">ql</span><span class="p">.</span><span class="n">listing</span><span class="p">.</span><span class="n">getCodeUnitAt</span><span class="p">(</span><span class="n">target_address</span><span class="p">)</span>
        <span class="n">comment</span> <span class="o">=</span> <span class="s">"{}.{}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">func_dll</span><span class="p">,</span> <span class="n">func_name</span><span class="p">)</span>
        <span class="n">codeUnit</span><span class="p">.</span><span class="n">setComment</span><span class="p">(</span><span class="n">codeUnit</span><span class="p">.</span><span class="n">PRE_COMMENT</span><span class="p">,</span> <span class="n">comment</span><span class="p">)</span>
</code></pre></div></div>

<p>Now we have a Ghidra script that will use Python3 to run samples trough Qiling and extract dynamic resolved function names and comment them into Ghidra. See the final result:</p>

<p><img src="/img/daily-binary-emulation7.png" alt="Ghidra interface after adding comments" /></p>

<p>And we are done. :)</p>

<h3 id="tips-and-tricks">Tips and tricks</h3>
<p>Two tricks helped me to make this script. First of all, tracing the binary and printing assembly instructions can help a lot while debugging <a href="https://github.com/qilingframework/qiling/blob/master/examples/hello_x8664_linux_disasm.py">source!</a>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">md</span> <span class="o">=</span> <span class="n">Cs</span><span class="p">(</span><span class="n">CS_ARCH_X86</span><span class="p">,</span> <span class="n">CS_MODE_64</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">print_asm</span><span class="p">(</span><span class="n">ql</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
    <span class="n">buf</span> <span class="o">=</span> <span class="n">ql</span><span class="p">.</span><span class="n">mem</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">md</span><span class="p">.</span><span class="n">disasm</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">address</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">":: 0x%x:</span><span class="se">\t</span><span class="s">%s</span><span class="se">\t</span><span class="s">%s"</span> <span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">address</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">mnemonic</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">op_str</span><span class="p">))</span>

<span class="n">ql</span><span class="p">.</span><span class="n">hook_code</span><span class="p">(</span><span class="n">print_asm</span><span class="p">)</span>
</code></pre></div></div>

<p>You can compare emulation result with your disassembler to debug your program.</p>

<p>The second tip is when you try to run a time-consuming script and write something back to Ghidra (like adding a comment) you may face with an error like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ERROR (BackgroundCommandTask) Command Failure: An unexpected error occurred while processing the command: Auto Analysis java.lang.RuntimeException: Timed-out waiting to run a Swing task--potential deadlock!
</code></pre></div></div>

<p>It’s because java closed the file and to solve this problem you need to increase timeout. Open the file in <code class="language-plaintext highlighter-rouge">ghidra/support/launch.properties</code> and add this line:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">VMARGS</span><span class="o">=</span><span class="nt">-Dghidra</span>.util.Swing.timeout.seconds<span class="o">=</span>3600
</code></pre></div></div>

<h3 id="conclusion">Conclusion</h3>

<p>The idea described in this article can be extended and used to analyze any other malware families that dynamically resolve imports. It’s not an ultimate general solution and you need to change things a little bit to match it against your target binary. I tried to explain my mindset behind the scene as much as possible to help you in this process. Hope this post was helpful.</p>

<p>Don’t hesitate to ping me if there is something wrong or if you want to discuss about the post. I dropped the final script and the malware sample <a href="https://github.com/lopqto/YaraRules/tree/master/malwares/netwalker">here!</a>.</p>

<h3 id="read-more">Read more</h3>

<ul>
  <li><a href="https://qiling.io/">Qiling website</a></li>
  <li><a href="https://docs.qiling.io/">Qiling docs</a></li>
  <li><a href="https://ghidra.re/ghidra_docs/api/index.html">Ghidra docs</a></li>
  <li><a href="https://www.youtube.com/watch?v=R4xJou6JsIE">IDA Pro Scripting Intro - Automate Dynamic Import Resolving for REvil Ransomware</a></li>
</ul>

  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="https://gravatar.com/avatar/2299d4e1a3508f63aaac7d956f41784372595562de6274dc0157c107ae2c4d07?v=1755405717000&size=256" alt="Hamidreza Babaee">
  <div class="col-box-title name">Hamidreza Babaee</div>
  <p>Poking around to find out.</p>
  <p class="contact">
    
    
    
    <a href="mailto:morpix@pm.me">Email</a>
    
    <a href="https://github.com/lopqto">GitHub</a>
    
    <a href="https://twitter.com/lopqto">Twitter</a>
    
  </p>
</div>


<div class="col-box post-toc hide">
  <div class="col-box-title">TOC</div>
  <div class="toc-body"></div>
</div>


        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
&copy; 2025 Hamidreza Babaee
</div>
</footer>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>


  </body>

</html>
